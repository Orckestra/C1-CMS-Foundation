/**
* Composite table plugin.
*/
new function () {

	var each = tinymce.each, Event = tinymce.dom.Event;

	var URL_TABLE = "${tiny}/plugins/compositetable/table.aspx";
	var URL_ROW = "${tiny}/plugins/compositetable/row.aspx";
	var URL_CELL = "${tiny}/plugins/compositetable/cell.aspx";
	var URL_MERGE = "${tiny}/plugins/compositetable/merge.aspx";

	tinymce.create("tinymce.plugins.CompositeTablePlugin", {

		/**
		* @type {tinymce.Editor}
		*/
		editor: null,

		/**
		* @type {tinymce.Theme}
		*/
		theme: null,

		/**
		* Get info
		*/
		getInfo: function () {
			return {
				longname: "Composite Table Plugin",
				author: "Orckestra A/S",
				authorurl: "https://c1.orckestra.com/",
				infourl: null,
				version: tinymce.majorVersion + "." + tinymce.minorVersion
			};
		},

		/**
		* @param {tinymce.Editor} ed
		* @param {string} url
		*/
		init: function (ed, url) {
			var TABLE_INSERT_P_BEFORE = 'INSERT_P_BEFORE';
			var TABLE_UNKNOWN = 'UNKNOWN';
			var state = TABLE_UNKNOWN;

			function isEnter(e) {
				return e.keyCode === tinymce.util.VK.ENTER;
			}

			function isEnterWithoutShift(e) {
				return isEnter(e) && !e.shiftKey;
			}

			function getListKeyState(e) {
				if (isEnterWithoutShift(e) && isRequiredParagraphBefore()) {
					return TABLE_INSERT_P_BEFORE;
				} else {
					return TABLE_UNKNOWN;
				}
			}

			function cancelDefaultEvents(e) {
				if (state == TABLE_INSERT_P_BEFORE) {
					Event.cancel(e);
				}
			}

			function isRequiredParagraphBefore() {
				var focusElm = ed.selection.getStart();
				var tdElm = ed.dom.getParent(focusElm, "td,th");
				if (tdElm && !tdElm.previousElementSibling) {
					var trElm = ed.dom.getParent(tdElm, "tr");
					if (trElm && !trElm.previousElementSibling) {
						var range = ed.selection.getRng(true);
						if (range.startOffset == 0 && range.endOffset == 0) {
							var tableElm = ed.dom.getParent(trElm, "table");
							if (tableElm && (!tableElm.previousElementSibling || tableElm.previousElementSibling.nodeName.toLowerCase() != "p")) {
								return true;
							}
						}
					}
				}
				return false;
			}

			this.editor = ed;
			this.theme = this.editor.theme;

			/*
			* Fixes a bug in FF3.0 where the cursor gets stuck in  
			* a table when the table is the last element on page.
			*/
			ed.on('NodeChange', function (e) {
				var body = ed.getBody();
				if (body.hasChildNodes()) {
					if (body.lastChild.nodeName.toLowerCase() == "table") {
						body.appendChild(body.ownerDocument.createElement("p"));
					}
				}
			});

			//Add Bogus BR to empty TDs
			ed.on('BeforeSetContent', function (e) {
				if (!Client.isExplorer)
					e.content = e.content.replace(/<td><\/td>/g, '<td><br data-mce-bogus="1"/></td>');
			});

			//Insert paragraph before table on Enter
			ed.on('KeyUp', function (e) {
				if (state == TABLE_INSERT_P_BEFORE) {
					var focusElm = ed.selection.getStart();
					var tableElm = ed.dom.getParent(focusElm, "table");
					var body = ed.getBody();
					p = body.ownerDocument.createElement("p");
					if (!Client.isExplorer) {
						p.innerHTML = '<br data-mce-bogus="1">';
					}
					tableElm.parentNode.insertBefore(p, tableElm);
					ed.selection.setCursorLocation(p, 0);
				}
			});

			ed.on('KeyDown', function (e) { state = getListKeyState(e); });
			ed.on('KeyDown', cancelDefaultEvents);


		},

		/**
		* @param {string} cmd
		* @param {boolean} ui
		* @param {string} value
		*/
		execCommand: function (cmd, ui, value) {

			var result = false;
			var editor = this.editor;
			var editorBinding = editor.theme.editorBinding;

			switch (cmd) {
				case "compositeInsertTable":
				case "compositeTableRowProps":
				case "compositeTableCellProps":
					var element = editor.selection.getNode();
					editor.execCommand("mceBeginUndoLevel");
					this._doExecCommand(element, cmd, ui, value);
					editor.execCommand("mceEndUndoLevel");
				case "mceTableSplitCells":
				case "mceTableMergeCells":
				case "mceTableInsertRowBefore":
				case "mceTableInsertRowAfter":
				case "mceTableDeleteRow":
				case "mceTableInsertColBefore":
				case "mceTableInsertColAfter":
				case "mceTableDeleteCol":
				case "mceTableCutRow":
				case "mceTableCopyRow":
				case "mceTablePasteRowBefore":
				case "mceTablePasteRowAfter":
				case "mceTableDelete":
					setTimeout(function () {
						editorBinding.checkForDirty();
					}, 0)
					result = true;
					break;
			}

			return result;
		},

		/**
		* 
		*/
		_doExecCommand: function (element, command, user_interface, value) {

			var inst = this.editor, ed = inst, url = this.url;
			var focusElm = inst.selection.getStart();
			var trElm = inst.dom.getParent(focusElm, "tr");
			var tdElm = inst.dom.getParent(focusElm, "td,th");
			var tableElm = inst.dom.getParent(focusElm, "table");
			var doc = inst.contentWindow.document;

			// ---- Commands -----

			// Handle commands
			switch (command) {

				case "compositeTableRowProps":

					if (trElm != null) {

						this.editor.theme.enableDialogMode();

						// construct dialog argument.
						var dialogArgument = {
							tinyAction: value,
							tinyWindow: window,
							tinyElement: trElm,
							tinyEngine: tinymce,
							tinyInstance: this.editor,
							tinyTheme: this.editor.theme,
							editorBinding: this.editor.theme.editorBinding
						}

						var self = this;
						var dialogHandler = {
							handleDialogResponse: function (response, result) {

								self.editor.theme.disableDialogMode();

								if (response == Dialog.RESPONSE_ACCEPT) {

									switch (result.get("action")) {
										case "row":
											self._updateTableRow(trElm, result);
											break;
										case "all":
											new List(tableElm.rows).each(function (row) {
												self._updateTableRow(row, result);
											});
											break;
										case "odd":
										case "even":
											var i = 0;
											new List(tableElm.rows).each(function (row) {
												if ((i % 2 == 0 && result.get("action") == "odd") || (i % 2 != 0 && result.get("action") == "even")) {
													self._updateTableRow(row, result);
												}
												i++;
											});
											break;
									}

									self.editor.addVisual(tableElm);
									self.editor.nodeChanged();
								}
							}
						}

						// open dialog
						Dialog.invokeModal(
							URL_ROW,
							dialogHandler,
							dialogArgument
						);

					}

					return true;

				case "compositeTableCellProps":
					if (tdElm != null) {

						this.editor.theme.enableDialogMode();

						// construct dialog argument.
						var dialogArgument = {
							tinyAction: value,
							tinyWindow: window,
							tinyElement: tdElm,
							tinyEngine: tinymce,
							tinyInstance: this.editor,
							tinyTheme: this.editor.theme,
							editorBinding: this.editor.theme.editorBinding
						}

						var self = this;
						var dialogHandler = {
							handleDialogResponse: function (response, result) {

								self.editor.theme.disableDialogMode();

								if (response == Dialog.RESPONSE_ACCEPT) {

									switch (result.get("action")) {
										case "cell":
											self._updateTableCell(tdElm, result);
											break;
										case "row":
											new List(tdElm.parentNode.cells).each(function (cell) {
												self._updateTableCell(cell, result);
											});
											break;
										case "all":
											new List(tableElm.rows).each(function (row) {
												new List(row.cells).each(function (cell) {
													self._updateTableCell(cell, result);
												});
											});
											break;
									}

									self.editor.addVisual(tableElm);
									self.editor.nodeChanged();
								}
							}
						}

						// open dialog
						Dialog.invokeModal(
							URL_CELL,
							dialogHandler,
							dialogArgument
						);
					}

					return true;

				case "compositeInsertTable":

					if (user_interface) {

						this.editor.theme.enableDialogMode();

						// when updating, pinpoint the target table
						var table = null;

						if (value == "update") {
							table = tableElm;
						}

						// construct dialog argument.
						var dialogArgument = {
							tinyAction: value,
							tinyWindow: window,
							tinyElement: table,
							tinyEngine: tinymce,
							tinyInstance: this.editor,
							tinyTheme: this.editor.theme,
							editorBinding: this.editor.theme.editorBinding
						}

						// construct dialog handler.

						var self = this;
						var dialogHandler = {
							handleDialogResponse: function (response, result) {

								self.editor.theme.disableDialogMode();

								if (response == Dialog.RESPONSE_ACCEPT) {
									switch (dialogArgument.tinyAction) {
										case "insert":
											self._insertTable(result);
											break;
										case "update":
											self._updateTable(result);
											break;
									}
									self.editor.nodeChanged();
								}
							}
						}

						// open dialog
						Dialog.invokeModal(
							URL_TABLE,
							dialogHandler,
							dialogArgument
						);
					}

					return true;
			}
		},

		cleanup: function (table) {
			var selection = this.editor.selection, dom = selection.dom;
			var rng = dom.createRng(), row;

			// Empty rows
			each(dom.select('tr', table), function (tr) {
				if (tr.cells.length === 0) {
					dom.remove(tr);
				}
			});

			// Empty table
			if (dom.select('tr', table).length === 0) {
				rng.setStartBefore(table);
				rng.setEndBefore(table);
				selection.setRng(rng);
				dom.remove(table);
				return;
			}

			// Empty header/body/footer
			each(dom.select('thead,tbody,tfoot', table), function (part) {
				if (part.rows.length === 0) {
					dom.remove(part);
				}
			});

		},

		_insertTable: function (result) {

			var inst = this.editor;
			var html = '<table';

			html += makeAttrib('id', result.get("id"));
			html += makeAttrib('class', result.get("classname"));
			html += makeAttrib('summary', result.get("summary"));
			html += '>';

			for (var y = 0; y < result.get("rows") ; y++) {
				html += "<tr>";
				for (var x = 0; x < result.get("cols") ; x++) {
					if (!Client.isExplorer)
						html += '<td><br data-mce-bogus="1"/></td>';
					else
						html += '<td></td>';
				}
				html += "</tr>";
			}

			html += "</table>";

			inst.execCommand('mceBeginUndoLevel');

			/*
			* The following goob is here to make sure that  
			* tables dont get positioned inside p elements.
			*/

			var bm = inst.selection.getBookmark(), patt = '';
			inst.execCommand('mceInsertContent', false, '<br class="_mce_marker" />');

			tinymce.each('h1,h2,h3,h4,h5,h6,p'.split(','), function (n) {
				if (patt) {
					patt += ',';
				}
				patt += n + ' ._mce_marker';
			});

			var dom = inst.dom;
			tinymce.each(inst.dom.select(patt), function (n) {
				inst.dom.split(inst.dom.getParent(n, 'h1,h2,h3,h4,h5,h6,p'), n);
			});

			dom.setOuterHTML(dom.select('._mce_marker')[0], html);

			inst.selection.moveToBookmark(bm);

			inst.addVisual();
			inst.execCommand('mceEndUndoLevel');
		},

		/**
		* Update table.
		* @param {HashMap<string><object>}
		*/
		_updateTable: function (result) {

			this.editor.execCommand('mceBeginUndoLevel');

			var dom = this.editor.dom;
			var table = this.editor.dom.getParent(
				this.editor.selection.getNode(),
				"table"
			);
			if (table != null) {
				dom.setAttrib(table, "class", result.get("classname"));
				dom.setAttrib(table, "id", result.get("id"));
				dom.setAttrib(table, "summary", result.get("summary"));
			}

			this.editor.addVisual();
			this.editor.nodeChanged();
			this.editor.execCommand('mceEndUndoLevel');
		},

		/**
		* Update cell.
		* @param {DOMElement} td
		* @param {HashMap<string><object>}
		*/
		_updateTableCell: function (td, result) {

			try {

				if (DOMUtil.getLocalName(td) != result.get("cellType")) {
					var doc = DOMUtil.getParentWindow(td).document;
					var cell = doc.createElement(result.get("cellType"));
					cell.innerHTML = td.innerHTML;
					new List(td.attributes).each(function (att) {
						cell.setAttribute(att.nodeName, att.nodeValue);
					});
					td.parentNode.replaceChild(cell, td);
					td = cell;
				}
				if (result.get("id")) {
					td.id = result.get("id");
				} else {
					td.id = null;
					td.removeAttribute("id");
				}
				if (result.get("classname")) {
					td.className = result.get("classname");
					td.setAttribute("class", result.get("classname"));
				} else {
					td.className = null;
					td.removeAttribute("class");
				}
				if (result.get("align")) {
					td.setAttribute("align", result.get("align"));
				} else {
					td.removeAttribute("align");
				}
				if (result.get("valign")) {
					td.setAttribute("valign", result.get("valign"));
				} else {
					td.removeAttribute("valign");
				}
				if (result.get("width")) {
					td.setAttribute("width", result.get("width"));
				} else {
					td.removeAttribute("width");
				}

			} catch (e) {
				alert(e);
				SystemDebug.stack(arguments);
			}
		},

		/**
		* Update row.
		* @param {DOMElement} td
		* @param {HashMap<string><object>}
		*/
		_updateTableRow: function (tr, result) {

			var currentposition = DOMUtil.getLocalName(tr.parentNode).toLowerCase();
			var position = result.get("rowtype");

			if (position != currentposition) {
				var row = tr.cloneNode(true);
				var table = this.editor.dom.getParent(tr, "table");
				var target = null;
				switch (position) {
					case "thead":
						target = table.createTHead();
						break;
					case "tfoot":
						target = table.createTFoot();
						break;
					case "tbody":
						target = table.getElementsByTagName("tbody").item(0);
						break;
				}
				target.appendChild(row);
				tr.parentNode.removeChild(tr);
				tr = row;
			}

			if (result.get("classname")) {
				tr.className = result.get("classname");
				tr.setAttribute("class", result.get("classname"));
			} else {
				tr.className = "";
				tr.removeAttribute("class");
			}
			if (result.get("align")) {
				tr.setAttribute("align", result.get("align"));
			} else {
				tr.removeAttribute("align");
			}
			if (result.get("valign")) {
				tr.setAttribute("valign", result.get("valign"));
			} else {
				tr.removeAttribute("valign");
			}

			this.cleanup(table);
		}
	});

	// Register plugin
	tinymce.PluginManager.add("compositetable", tinymce.plugins.CompositeTablePlugin);
};